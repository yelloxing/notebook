<header>
    算法引论
</header>
<h2>
    算法与程序
</h2>
<p>
    通俗地讲，
    <span class="important">算法</span>
    是指解决问题的方法或过程。严格地讲，算法是满足下述性质的指令序列：
</p>
<ol>
    <li>
        输入：有零个或多个外部量作为算法的输入。
    </li>
    <li>
        输出：算法产生至少一个量作为输出。
    </li>
    <li>
        确定性：组成算法的每条指令是清晰度、无歧义的。
    </li>
    <li>
        有限性：算法中每条指令的执行次数有限，执行每条指令的时间也有限。
    </li>
</ol>
<p>
    而
    <span class="important">程序</span>
    与算法不同， 程序是算法用某种程序设计语言的具体实现。
</p>
<p>
    程序可以不满足算法的性质（4）即有限性，例如操作系统，它是在无限循环中执行的程序。然而，可把操作系统的各种任务看成一些单独的问题，每一个问题由操作系统中的一个子程序通过特定的算法实现，该子程序得到输出结果后便停止。
</p>
<h2>
    表达算法的抽象机制
</h2>
<p>
    对于一个明确的数学问题，设计它的算法，总是先选用该问题的一个数据模型。
</p>
<p>
    接着弄清楚该问题数据模型在已知条件下的初始状态和要求的结果状态，以及这两个状态之间的隐含关系。
</p>
<p>
    然后探索从数据模型的已知初始状态到达要求的结果状态所需的运算步骤（这些运算步骤就是求解该问题的算法）。
</p>
<h2>
    算法复杂性分析
</h2>
<p>
    算法复杂性的高低体现在运行该算法所需要的计算机资源的多少上，所需要的资源越多，该算法的复杂性越高，反之就越低。
</p>
<p>
    而计算机中，最重要的资源就是时间和空间（即存储器），因此，算法的复杂性有
    <span class="important">时间复杂性</span>
    和
    <span class="important">空间复杂性</span>
    之分。 对于任意一个给定的问题，设计出复杂性尽可能低的算法是在设计算法时追求的重要目标。
</p>
<p>
    但是，在有些情况下，复杂性的追求也不完全是越低越好，比如：可读性、可扩展等也很重要，需要结合实际情况选择，切莫陷入“虚无的理想主义者”陷阱中去。
</p>